<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>üéâ Carte 3D ‚Äî Chats face cam√©ra</title>
    <link rel="preconnect" href="https://unpkg.com">
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3.4.38/dist/vue.esm-browser.prod.js",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js",
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
          }
        }
    </script>
    <style>
        :root {
            --bg1:#0a1024;
            --bg2:#0b1430;
            --panel:rgba(255,255,255,.07);
            --txt:#e9f1ff;
        }
        html,body {
            height:100%;
            margin:0;
            font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
            background:radial-gradient(900px 700px at 65% 12%, var(--bg2), var(--bg1));
            color:var(--txt);
        }
        .app{display:flex;flex-direction:column;height:100%}
        .stage{position:relative;flex:1;min-height:520px}
        canvas{position:absolute;inset:0;display:block;z-index:1}
        .hud{position:absolute;left:16px;top:16px;display:flex;gap:8px;z-index:10}
        .hud button{background:var(--panel);color:var(--txt);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px 12px;cursor:pointer}
        .ctrl{ display:none;position:absolute;right:16px;top:16px;background:var(--panel);backdrop-filter:blur(6px);
            border:1px solid rgba(255,255,255,.12);padding:10px;border-radius:12px;z-index:10}
        .ctrl label{font-size:12px;opacity:.85}
        .ctrl input[type="text"]{width:280px;background:transparent;border:1px solid rgba(255,255,255,.12);color:var(--txt);border-radius:8px;padding:6px}
        .final-line{position:absolute;left:50%;top:9%;transform:translateX(-50%);font-weight:900;
            font-size:clamp(22px,4.2vw,44px);letter-spacing:.3px;opacity:0;text-align:center;text-shadow:0 12px 32px rgba(0,0,0,.55);z-index:50;pointer-events:none}
        .credit{position:absolute;right:16px;bottom:12px;opacity:.55;font-size:12px}
    </style>
</head>
<body>
<div id="app" class="app">
    <div class="stage" ref="stage">
        <div class="hud">
            <button @click="play">‚ñ∂ Play</button>
            <button @click="reset">‚Ü∫ Reset</button>
        </div>

        <div class="ctrl">
            <div>
                <label>Vitesse</label><br>
                <input type="range" min="0.6" max="1.8" step="0.05" v-model.number="speed">
            </div>
            <div style="margin-top:8px">
                <label>Mots (s√©par√©s par virgule)</label><br>
                <input type="text" v-model="wordsText" placeholder="Joyeux,anniversaire,ma,grande,s≈ìur">
            </div>
        </div>

        <div class="final-line" ref="finalLine">Joyeux anniversaire ma grande s≈ìur üíñ</div>
    </div>
    <div class="credit">Vue + Three.js + GSAP ‚Äî plan chats orient√© cam√©ra üêà</div>
</div>

<script type="module">
    import { createApp, ref, onMounted } from 'vue'
    import { gsap } from 'gsap'
    import * as THREE from 'three'

    createApp({
        setup(){
            const stage = ref(null)
            const finalLine = ref(null)
            const speed = ref(2.0)
            const wordsText = ref('Joyeux,anniversaire,ma,grande,s≈ìur')

            let renderer, scene, camera
            let boxGroup, hinge, lid, heroCat
            let catsLayer, clones = []
            let sheetTex
            let followTargetY = 1.6
            let allLetterGroups = []

            // Offsets fixes (ajuste ici pour le placement du plan chats)
            const offsetX = -1.9
            const offsetY = 0.4
            const offsetZ = -2.9

            // ---- sprite lettres ----
            function makeLetterSprite(ch){
                const font = '900 36px Inter, Arial, sans-serif'
                const canvas = document.createElement('canvas')
                const ctx = canvas.getContext('2d')
                ctx.font = font
                const w = Math.ceil(ctx.measureText(ch).width)+20, h = 64
                canvas.width = w; canvas.height = h
                ctx.font = font
                ctx.fillStyle='#fff'
                ctx.shadowColor='#000'; ctx.shadowBlur=8; ctx.textBaseline='middle'
                ctx.fillText(ch,10,h/2)
                const tex = new THREE.CanvasTexture(canvas)
                tex.minFilter = THREE.LinearFilter
                const mat = new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false})
                const sprite = new THREE.Sprite(mat)
                sprite.scale.set(w*0.012,h*0.012,1)
                sprite.material.opacity=0
                return sprite
            }

            function confettisBurst(){
                for(let i=0;i<90;i++){
                    const color=new THREE.Color(`hsl(${Math.random()*360},80%,60%)`)
                    const conf=new THREE.Sprite(new THREE.SpriteMaterial({color}))
                    conf.scale.setScalar(0.05+Math.random()*0.06)
                    conf.position.set((Math.random()-0.5)*6,3.2+Math.random()*3.2,(Math.random()-0.5)*3)
                    scene.add(conf)
                    gsap.to(conf.position,{y:"-=6.5",duration:2+Math.random()*2,ease:"power1.in",onComplete:()=>scene.remove(conf)})
                    gsap.to(conf.material,{opacity:0,duration:2.5,delay:1})
                }
            }

            function matFromSheet(index){
                const mat=new THREE.MeshBasicMaterial({map:sheetTex.clone(),transparent:true})
                mat.map.repeat.set(0.5,0.5)
                const ox=(index%2)*0.5
                const oy=(index<2)?0.5:0.0
                mat.map.offset.set(ox,oy)
                mat.map.needsUpdate=true
                mat.depthTest=false
                mat.opacity=0
                return mat
            }

            function buildScene(el){
                scene=new THREE.Scene()
                camera=new THREE.PerspectiveCamera(38,el.clientWidth/el.clientHeight,0.1,100)
                camera.position.set(7,6,11)
                camera.lookAt(0,1.6,0)
                renderer=new THREE.WebGLRenderer({antialias:true,alpha:true})
                renderer.setSize(el.clientWidth,el.clientHeight)
                el.appendChild(renderer.domElement)
                scene.add(new THREE.HemisphereLight(0xffffff,0x334466,1))

                // Coffret
                boxGroup=new THREE.Group()
                const base=new THREE.Mesh(new THREE.BoxGeometry(2.8,1.8,2.2),new THREE.MeshStandardMaterial({color:'#b07f4d'}))
                base.position.y=0.9
                lid=new THREE.Mesh(new THREE.BoxGeometry(3,0.25,2.4),new THREE.MeshStandardMaterial({color:'#cfa477'}))
                hinge=new THREE.Group(); hinge.position.set(0,2.02,-1.2); hinge.add(lid)
                boxGroup.add(base,hinge)
                boxGroup.rotation.y=Math.PI/6
                scene.add(boxGroup)

                // Chat principal
                const heroTex=new THREE.TextureLoader().load('5d1bcb01-f06d-43c3-ae74-9ec0fbf3f9f0.png')
                heroCat=new THREE.Mesh(
                    new THREE.PlaneGeometry(2,2),
                    new THREE.MeshBasicMaterial({
                        map: heroTex,
                        transparent: true,
                        depthTest: false,   // ‚úÖ ne tient plus compte de la profondeur
                        depthWrite: false,  // ‚úÖ n‚Äôaffecte pas le buffer de profondeur
                    })
                )
                heroCat.renderOrder = 9999
                heroCat.position.set(-5.2,3.6,0.2)
                heroCat.rotation.y=Math.PI/12
                scene.add(heroCat)

                // Sprite sheet chats
                sheetTex=new THREE.TextureLoader().load('93583320-0ee0-4017-a706-2d87189619e5.png')
                sheetTex.minFilter=THREE.LinearMipMapLinearFilter

                // Calque des chats
                catsLayer = new THREE.Group()
                catsLayer.position.set(offsetX, offsetY, offsetZ)
                scene.add(catsLayer)

                // Rendu
                renderer.setAnimationLoop(()=>{
                    camera.position.y = THREE.MathUtils.lerp(camera.position.y, followTargetY, 0.05)
                    camera.lookAt(0,1.6,0)
                    // les chats regardent la cam√©ra
                    if (catsLayer) catsLayer.lookAt(camera.position)
                    renderer.render(scene,camera)
                })
            }

            function play(){
                reset()
                const wordPositions = [
                    { x:-22,  y: 5.8, z: 0 },
                    { y: 4.9, z: -0.1 },
                    { y: 4.6, z: 0.1 },
                    { x:-22, y: 3.9, z: -0.2 },
                    { y: 3.3, z: 0.2 },
                    { y: 3.6, z: 0 }
                ]

                const tl=gsap.timeline({defaults:{ease:'power3.out'},timeScale:speed.value})

                tl.fromTo(heroCat.position,{x:4.2,y:6.2},{x:0.85,y:2.15,z:0.2,duration:1.25,ease:'power2.in'})
                    .to(heroCat.rotation,{z:-0.15,duration:0.18,yoyo:true,repeat:3,ease:'sine.inOut'},"<+0.45")
                    .to(boxGroup.position,{y:"+=0.05",yoyo:true,repeat:4,duration:0.07,ease:'sine.inOut'},"<+0.45")
                    .to(heroCat.position,{y:1.0,z:-0.6,duration:0.45,ease:'power2.in'},">-0.05")
                    .set(heroCat,{visible:false})

                tl.to(hinge.rotation,{x:-Math.PI*0.92,duration:0.85},"-=0.2")
                    .add(()=>{followTargetY=4.4},"<+0.4")

                const words=wordsText.value.split(',').map(s=>s.trim()).filter(Boolean)
                const spacing=.8
                const letterSpacing=.45
                clones.forEach(m=>catsLayer.remove(m)); clones=[]
                allLetterGroups=[]

                let indices=[0,1,2,3]
                while(words.length>indices.length) indices.push(...indices)
                indices=gsap.utils.shuffle(indices)

                for(let i=0;i<words.length;i++){
                    const idx=indices[i%indices.length]
                    const mat=matFromSheet(idx)
                    const m=new THREE.Mesh(new THREE.PlaneGeometry(1.7,1.7),mat)
                    m.visible=false
                    m.position.set(0,0,0)
                    m.scale.set(0.5,0.5,1)
                    m.renderOrder=10
                    m.material.depthTest=false
                    catsLayer.add(m)
                    clones.push(m)

                    const landX=(i-(words.length-1)/2)*0.6
                    const landY=0.85+Math.random()*0.2
                    const landZ=2.3+(Math.random()-0.5)*0.3

                    tl.set(m,{visible:true},">")
                        .fromTo(m.material,{opacity:0},{opacity:1,duration:0.3,ease:"power2.out"},">")
                        .to(m.position,{y:5.0,x:landX*0.8,z:1.0,duration:0.9,ease:'power2.out'},"<+0.05")
                        .to(m.scale,{x:1.1,y:1.1,duration:0.4,ease:'back.out(2)'}, "<")
                        .add(()=>{
                            const pos = wordPositions[i] || { y: 4.8, z: 0 }
                            const g = lettersPop(words[i], landX, letterSpacing, pos)
                            catsLayer.add(g)
                            allLetterGroups.push(g)
                            confettisBurst()
                        },"<+0.3")
                        .to(m.position,{y:landY,x:landX,z:landZ,duration:0.9,ease:'bounce.out'},"<+0.8")
                        .to(m.scale,{x:0.6,y:0.6,duration:0.6,ease:'power2.inOut'},"<")
                        .to(m.material,{opacity:1,duration:0.6,ease:"power1.inOut"},"<+0.2")
                }

                tl.call(()=>alignAllLetters(), null, "+=0.8")
                tl.to(finalLine.value,{opacity:1,duration:1,ease:'power2.out'}, "<+0.6")
                    .add(()=>{followTargetY=4.0},"<+0.2")
            }

            function lettersPop(word, baseX, letterSpacing, pos = { y: 3.5, z: -0.5 }) {
                const letters = word.split('')
                const group = new THREE.Group()
                const easeWord = word.length > 5 ? "back.out(2)" : "bounce.out"
                letters.forEach((ch, i) => {
                    const s = makeLetterSprite(ch || ' ')
                    s.position.set(baseX + i * letterSpacing, pos.y, pos.z)
                    s.scale.multiplyScalar(1.25)
                    group.add(s)
                    s.material.opacity = 1
                    gsap.fromTo(s.scale, { x: 0, y: 0 }, { x: 1, y: 1, duration: 0.42, ease: easeWord, delay: i * 0.05 })


                    // ü™∂ animation de "flottement" subtile avant disparition
                    const driftX = (Math.random() - 0.5) * 0.3
                    const driftY = 0.3 + Math.random() * 0.4
                    gsap.to(s.position, {
                        x: s.position.x + driftX,
                        y: s.position.y + driftY,
                        duration: 3.5,
                        ease: "sine.inOut",
                        delay: 1.2 + i * 0.05
                    })
                    gsap.to(s.material, {
                        opacity: 0,
                        duration: 2.8,
                        ease: "sine.inOut",
                        delay: 1.5 + i * 0.05
                    })
                })
                return group
            }

            function alignAllLetters(){
                allLetterGroups.forEach((group)=>{
                    group.children.forEach((sprite)=>{
                        gsap.to(sprite.scale,{x:0.4,y:0.4,duration:1.2,ease:"power2.inOut",delay:0.7})
                        gsap.to(sprite.material,{opacity:0,duration:1.4,ease:"sine.inOut",delay:0.7})
                    })
                })
            }

            function reset(){
                gsap.killTweensOf('*')
                if(heroCat){heroCat.visible=true;heroCat.position.set(-5.2,3.6,0.2);heroCat.rotation.set(0,Math.PI/12,0)}
                hinge.rotation.set(0,0,0)
                clones.forEach(m=>catsLayer.remove(m)); clones=[]
                allLetterGroups=[]
                followTargetY=1.6
                camera.position.set(7,6,11); camera.lookAt(0,1.6,0)
                if(finalLine.value){finalLine.value.style.opacity=0;finalLine.value.style.transform='translateX(-50%)'}
            }

            onMounted(()=>buildScene(stage.value))
            return { stage, finalLine, speed, wordsText, play, reset }
        }
    }).mount('#app')
</script>
</body>
</html>
